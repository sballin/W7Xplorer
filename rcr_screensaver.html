<html>

<head>
    <title>RCR screensaver</title>
    <style>
    body {
        margin: 0;
        background-color: #000000;
    }

    canvas {
        width: 100%;
        height: 100%;
    }

    h4, p {
        color: white;
        text-align: left;
    }
    </style>
    <script src="js/three.js"></script>
    <script src="js/STLLoader.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/THREE.TextSprite.js"></script>
    <script src="js/THREE.TextTexture.min.js"></script>
    <script src="js/jquery.min.js"></script>
    
    <script src="js/postprocessing/EffectComposer.js"></script>
    <script src="js/postprocessing/RenderPass.js"></script>
    <script src="js/postprocessing/ShaderPass.js"></script>
    <script src="js/shaders/CopyShader.js"></script>
    <script src="js/shaders/LuminosityHighPassShader.js"></script>
    <script src="js/postprocessing/UnrealBloomPass.js"></script>
</head>

<body>
    <script>
    var clock = new THREE.Clock();
    // Initialize scene and renderer
    var scene = new THREE.Scene();
    scene.background = new THREE.Color( 0x000000 );
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.001, 1e5);
    camera.up = new THREE.Vector3(0, 0, 1);
    camera.position.setX(0).setY(0).setZ(9);
    camera.setFocalLength(11.057);
    var origin = new THREE.Vector3(0,0,0);
    var renderer = new THREE.WebGLRenderer(
    {
        antialias: true,
        alpha: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
    renderer.sortObjects = false;
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = Math.pow( 1.1, 4.0 );
    document.body.appendChild(renderer.domElement);

    // Bloom
    var renderScene = new THREE.RenderPass( scene, camera );
    var bloomPass = new THREE.UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
    bloomPass.renderToScreen = true;
    bloomPass.threshold = 0.08;
    bloomPass.strength = 1.3;
    bloomPass.radius = 0;
    composer = new THREE.EffectComposer( renderer );
    composer.setSize( window.innerWidth, window.innerHeight );
    composer.addPass( renderScene );
    composer.addPass( bloomPass );
    
    // Browser camera controls
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 1;
    controls.enableZoom = true;
    controls.maxDistance = 20;
    controls.minDistance = 0.1;
    
    // Basic lights
    var ambientLight = new THREE.AmbientLight(0xffffff, 1);
    scene.add(ambientLight);
    var pointLight = new THREE.PointLight(0xffffff, 1);
    pointLight.position.set(0, 0, 100);
    pointLight.shadowMapVisible = true;
    scene.add(pointLight);
    
    // LCFS
    var LCFSDict = {};
    var LCFSr, LCFSz, LCFSphi;
    var currentConfig = 'A_standard_beta-0';
    var map = new THREE.TextureLoader().load( 'assets/textures/metal_iota_1_darkestest.png' );
    map.wrapS = map.wrapT = THREE.RepeatWrapping;
    map.anisotropy = 16;
    fetch('assets/lcfs/A_standard_beta-0.json').then(response => response.json()).then(json => LCFSDict[currentConfig] = plotLCFS(json));
    
    var bg = new THREE.TextureLoader().load( 'assets/textures/gradient.png' );
    var backgroundSphere  = new THREE.SphereGeometry(30, 60, 60);
    var material = new THREE.MeshBasicMaterial({map: bg, side: THREE.BackSide});
    scene.add(new THREE.Mesh(backgroundSphere, material));
    backgroundSphere.rotateX(Math.PI/2); // for seams to be at top and bottom of scene
    
    // addDivertor();
    addCoils();
    
    var render = function()
    {
        requestAnimationFrame(render);
        var et = clock.getElapsedTime();
        var speed = 0.3;
        map.offset = new THREE.Vector2((speed*et) % 1, (speed*et) % 1);
        camera.position.setX(8*Math.cos(0.17*et)).setY(8*Math.sin(0.17*et)).setZ(6*(Math.sin(0.19*et)+0.5));
        camera.lookAt(origin);
        
        // renderer.render(scene, camera); // normal renderer
        composer.render(); // bloom renderer
    };

    render();

    function addCoils()
    {
        var nonplanar = [522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571]
        var frequency = 2.4; //2*Math.PI/10;
        for (var i in nonplanar) {
            // Source: https://krazydad.com/tutorials/makecolors.php
            let red   = Math.floor(Math.sin(frequency*i + 0) * 127 + 128);
            let green = Math.floor(Math.sin(frequency*i + 2) * 127 + 128);
            let blue  = Math.floor(Math.sin(frequency*i + 4) * 127 + 128);
            let color = new THREE.Color('rgb(' + red + ', ' + green + ', ' + blue + ')');
            fetch('assets/coils/' + nonplanar[i] + '.json').then(response => response.json()).then(json => addLine(json, color));
        }
        var planar = [572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591];
        for (var i in planar) {
            fetch('assets/coils/' + planar[i] + '.json').then(response => response.json()).then(json => addLine(json, 0x333333));
        }
    }
    
    function addDivertor()
    {
        var ids = [170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309];
        for (var idi in ids)
            fetch('assets/divertor/' + ids[idi] + '.json').then(response => response.json()).then(json => addComponent(json));
    }
    
    function addLine(json, color)
    {
        var material = new THREE.LineBasicMaterial({color: color}); // was 0xFF00FF
        var geometry = new THREE.Geometry();
        for (var i = 0; i < json.x1.length; i++)
            geometry.vertices.push(new THREE.Vector3(json.x1[i], json.x2[i], json.x3[i]));
        var line = new THREE.Line( geometry, material );
        scene.add( line );
    }

    function addComponent(json)
    {
        var data = json.surfaceMesh;
        var vec = [];
        var faces = [];

        for (var i = 0; i < data.nodes.x1.length; i++)
            vec.push(new THREE.Vector3(data.nodes.x1[i], data.nodes.x2[i], data.nodes.x3[i]));

        if (data.numVertices[0] == 3)
        {
            for (var i = 0; i < data.polygons.length; i++)
                faces.push(new THREE.Face3(data.polygons[i++] - 1, data.polygons[i++] - 1, data.polygons[i] - 1));
        }
        else
        {
            for (var i = 0; i < data.polygons.length; i++)
            {
                v1 = data.polygons[i++] - 1;
                v2 = data.polygons[i++] - 1;
                v3 = data.polygons[i++] - 1;
                v4 = data.polygons[i] - 1;
                faces.push(new THREE.Face3(v1, v2, v3));
                faces.push(new THREE.Face3(v1, v3, v4));
            }
        }

        var geometry4 = new THREE.Geometry();
        geometry4.vertices = vec;
        geometry4.faces = faces;
        geometry4.computeFaceNormals();

        var material3 = new THREE.MeshStandardMaterial(
        {
            color: 0x666666,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.7,
            flatShading: false,
            metalness: 0.5,
            roughness: 0.5
        });
        var line4 = new THREE.Mesh(geometry4, material3);
        //line4.name = id.toString();
        scene.add(line4);
        var vec = geometry4.vertices[0];
        // addLabel(id.toString(), vec.x,vec.y, vec.z);
    }

    function addComponentById(id)
    {
        var compID = 'Component_' + id;
        var material3 = new THREE.MeshLambertMaterial(
        {
            color: 0x555555,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.7
        });

        $.ajax(
        {
            type: 'GET',
            url: 'http://esb.ipp-hgw.mpg.de:8280/services/ComponentsDbRest/component/' + id + '/data',
            dataType: 'json',
            success: function(json)
            {

                var data = json.surfaceMesh;

                if (data == undefined)
                    data = json.volumeMesh.faces;

                var vec = [];
                var faces = [];

                for (var i = 0; i < data.nodes.x1.length; i++)
                    vec.push(new THREE.Vector3(data.nodes.x1[i], data.nodes.x2[i], data.nodes.x3[i]));

                if (data.numVertices[0] == 3)
                {
                    for (var i = 0; i < data.polygons.length; i++)
                        faces.push(new THREE.Face3(data.polygons[i++] - 1, data.polygons[i++] - 1, data.polygons[i] - 1));
                }
                else
                {
                    for (var i = 0; i < data.polygons.length; i++)
                    {
                        v1 = data.polygons[i++] - 1;
                        v2 = data.polygons[i++] - 1;
                        v3 = data.polygons[i++] - 1;
                        v4 = data.polygons[i] - 1;
                        faces.push(new THREE.Face3(v1, v2, v3));
                        faces.push(new THREE.Face3(v1, v3, v4));
                    }
                }

                var geometry4 = new THREE.Geometry();
                geometry4.vertices = vec;
                geometry4.faces = faces;
                geometry4.computeFaceNormals();

                var line4 = new THREE.Mesh(geometry4, material3);
                line4.name = compID;
                scene.add(line4);
                var vec = geometry4.vertices[0];
                // addLabel(id.toString(), vec.x, vec.y, vec.z);
                // var lineEdges = new THREE.EdgesHelper(line4, 0x999999);
                // scene.add(lineEdges);
            },
            error: function(data)
            {
                console.log('Error getting component.');
            },
        });
    }

    function plotLCFS(input)
    {
        var LCFS = new THREE.Object3D();
        LCFS.points = [];
        var mat = new THREE.LineBasicMaterial(
        {
            linewidth: 1,
            color: 0x0000ff,
            transparent: true,
            opacity: 0.7
        });
        var lcfs_x = Array(80 * 252);
        var lcfs_y = Array(80 * 252);
        var lcfs_z = input.z;
        for (i = 0; i < 252; i++)
        {
            var geom = new THREE.Geometry();
            for (j = 0; j < 80; j++)
            {
                lcfs_x[i * 80 + j] = input.r[i * 80 + j] * Math.cos(input.phi[i]);
                lcfs_y[i * 80 + j] = input.r[i * 80 + j] * Math.sin(input.phi[i]);
                geom.vertices.push(new THREE.Vector3(lcfs_x[i * 80 + j], lcfs_y[i * 80 + j], lcfs_z[i * 80 + j]));
                LCFS.points.push([lcfs_x[i * 80 + j], lcfs_y[i * 80 + j], lcfs_z[i * 80 + j]]);
            }
            //if (i % 25 == 0)
            //    LCFS.add(new THREE.Line(geom, mat, THREE.LineSegments));
        }
        for (i = 0; i < 79; i++)
        {
            var geom = new THREE.Geometry();
            for (j = 0; j < 252; j++)
                geom.vertices.push(new THREE.Vector3(lcfs_x[i + j * 80], lcfs_y[i + j * 80], lcfs_z[i + j * 80]));
            geom.vertices.push(new THREE.Vector3(lcfs_x[i], lcfs_y[i], lcfs_z[i]));
            // LCFS.add(new THREE.Line(geom, mat, THREE.LineSegments));
        }
        LCFSr = input.r;
        LCFSz = input.z;
        LCFSphi = input.phi;
        var geometry = new THREE.ParametricGeometry(parametricLCFS, 252, 80);
        var material = new THREE.MeshPhongMaterial(
        {map: map, color: 0x156289, emissive: 0x072534,
                                                transparent: false, opacity: 0.8});
        LCFS.add(new THREE.Mesh(geometry, material));
        scene.add(LCFS);
        return LCFS;
    }

    function parametricLCFS(u, v, vector)
    {
        u = (u * 252) % 252;
        v = (v * 80) % 80;
        var r = LCFSr[v + u * 80];
        var z = LCFSz[v + u * 80];
        var phi = LCFSphi[u];
        vector.x = r * Math.cos(phi);
        vector.y = r * Math.sin(phi);
        vector.z = z;
    }

    function getLookAtVector(controls)
    {
        var phi = controls.getAzimuthalAngle();
        var theta = controls.getPolarAngle();
        return new THREE.Vector3(-Math.sin(theta) * Math.sin(phi), -Math.cos(theta), -Math.sin(theta) * Math.cos(phi));
    }

    function addSTL(filename)
    {
        var loader = new THREE.STLLoader();
        loader.load(filename, function(geometry)
        {
            var STLMaterial = new THREE.MeshPhongMaterial(
            {
                color: 0x888888,
                specular: 0xfff,
                shininess: 50,
                side: THREE.DoubleSide
            });
            var STL = new THREE.Mesh(geometry, STLMaterial);
            STL.scale.set(0.001, 0.001, 0.001);
            STL.castShadow = true;
            STL.receiveShadow = true;
            scene.add(STL);
        });
    }
    </script>
</body>

</html>
