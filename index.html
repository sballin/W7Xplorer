<html>
<head>
<title>W7-X visualizer</title>
<style>
    body {
        margin: 0;
    }
    
    canvas {
        width: 100%;
        height: 100%;
    }
    
    h4, p {
        color:white;
        text-align: left;
    }
    
body .dg .c,
body .dg .cr.function,
body .dg .c select,
body .dg .property-name,
body .dg .title {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}


body .dg.main.taller-than-window .close-button {
    border-top: 1px solid #ddd;
}

body .dg.main .close-button {
    background-color: #eee;
}
 
body .dg.main .close-button:hover {
    background-color: #eee;
}

body .dg {
    color: #555;
    text-shadow: none !important;
}

body .dg.main::-webkit-scrollbar {
    background: #fafafa;
}

body .dg.main::-webkit-scrollbar-thumb {
    background: #bbb;
}
 
body .dg li:not(.folder) {
    background: #fafafa;
    border-bottom: 1px solid #ddd;
}
 
body .dg li.save-row .button {
    text-shadow: none !important;
}

body .dg li.title {
    background: #e8e8e8 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;
}

body .dg li.folder {
    border-left: 0;
}

body .dg .cr.function:hover,
body .dg .cr.boolean:hover {
    background: #fff;
}
 
body .dg .c input[type=text] {
    background: #e9e9e9;
}
 
body .dg .c input[type=text]:hover {
    background: #eee;
}
 
body .dg .c input[type=text]:focus {
    background: #eee;
    color: #555;
}
 
body .dg .c .slider {
    background: #e9e9e9;
}

body .dg .c .slider:hover {
    background: #eee;
}

body .dg.a {
    margin-right: 9px;
    margin-top: 9px;
}

body .dg .cr.function {
    background: #eee;
}

body .dg .cr.function:hover {
    background: #dadada;
    border-bottom: 1px solid #2fa1d6;
}

body .dg .cr.function:active {
    background: #ddd;
    border-bottom: 1px solid #2fa1d6;
}
</style>
<script type="text/javascript" src="three.min.js"></script>
<script type="text/javascript" src="STLLoader.js"></script>
<script type="text/javascript" src="OrbitControls.js"></script>
<script type="text/javascript" src="dat.gui.min.js"></script>
<script type="text/javascript" src="THREE.TextSprite.js"></script>
<script type="text/javascript" src="THREE.TextTexture.min.js"></script>
</head>
<body>
<script>

// Initialize scene and renderer
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.001, 1e5);
camera.up = new THREE.Vector3( 0, 0, 1 );
camera.position.setX(-6).setY(7).setZ(4.5);
var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );
// camera.position.z = -2.5;

// Browser camera controls
controls = new THREE.OrbitControls( camera, renderer.domElement );
controls.enableDamping = true;
controls.dampingFactor = 1;
controls.enableZoom = true;
controls.maxDistance = 20;
controls.minDistance = 0.1;

// Basic lights
var ambientLight = new THREE.AmbientLight(0xffffff);
scene.add(ambientLight);
var pointLight = new THREE.PointLight( 0xffffff );
pointLight.position.set( 0, 0, 100 );
pointLight.shadowMapVisible = true;
scene.add(pointLight)

// Sun 
var dirLight = new THREE.DirectionalLight( 0xffffff, 0.05 );
dirLight.position.set( 0, -1, 0 ).normalize();
scene.add( dirLight );
dirLight.color.setHSL( 0.1, 0.7, 0.5 );
addLight( 0.995, 0.5, 0.9, 0, 3e3, 0);

// Add axes, hidden
addAxes( 0.5 );
// sceneAxes.visible = true;

fetch("lcfs.json").then(response => response.json()).then(json => plotLCFS(json));
addSTL('aek50_01.stl');
addLabel('AEK50', 0.5, -6, 2);
addSTL('aee11_01.stl');
addLabel('AEE11', 6, 0.5, 2);
addSTL('aee50_01.stl');
addLabel('AEE50', 2, -6, 2);
addSTL('aek10_01.stl');
addLabel('AEK10', 6, -1.5, 2);
addSTL('aek41_01.stl');
addLabel('AEK41', -4.3, -4.3, 2)
var chord;
plotChord();

var gui;
fetch("datGUIconfig.json").then(response => response.json()).then(json => makeGui(json));

var render = function()
{
    requestAnimationFrame( render );
    renderer.render(scene, camera);
};

render();

function makeGui(json) 
{
    gui = new dat.GUI({load: json});
    gui.remember(this.parent);
    this.startXYZ = chord.geometry.vertices[0];
    this.startR = Math.sqrt(startXYZ.x**2+startXYZ.y**2);
    this.startZ = startXYZ.z;
    this.startPhi = 2*Math.PI - Math.atan(startXYZ.y/startXYZ.x);
    this.endXYZ = chord.geometry.vertices[1];
    this.endR = Math.sqrt(endXYZ.x**2+endXYZ.y**2);
    this.endZ = endXYZ.z;
    this.endPhi = 2*Math.PI - Math.atan(endXYZ.y/endXYZ.x);
    var chordLength;
    updateChordLength();
    this.recalculate = updateChordLength;

    var controlsFolder = gui.addFolder('Controls');
    controlsFolder.add(controls, "zoomSpeed", 0.05, 1.0, 0.05);
    controlsFolder.add(controls, "rotateSpeed", 0.05, 1.0, 0.05);

    var startFolder = gui.addFolder('Start');
    startFolder.add(this, "startR", 4.0, 7.0, 0.001).onChange(function(value) 
                                                      {
                                                          startXYZ.x = value*Math.cos(startPhi);
                                                          startXYZ.y = value*Math.sin(startPhi);
                                                          chord.geometry.verticesNeedUpdate = true;
                                                          updateChordLength();
                                                      });
    startFolder.add(this, "startZ", -2.0, 2.0, 0.001).onChange(function(value) 
                                                       {
                                                           startXYZ.z = value;
                                                           chord.geometry.verticesNeedUpdate = true;
                                                           updateChordLength();
                                                       });
    startFolder.add(this, "startPhi", 0, 2*Math.PI, 0.001).onChange(function(value) 
                                                            {
                                                                startXYZ.x = startR*Math.cos(value);
                                                                startXYZ.y = startR*Math.sin(value);
                                                                chord.geometry.verticesNeedUpdate = true;
                                                                updateChordLength();
                                                            });

    var endFolder = gui.addFolder('End');
    endFolder.add(this, "endR", 4.0, 7.0, 0.001).onChange(function(value) 
                                                    {
                                                        endXYZ.x = value*Math.cos(endPhi);
                                                        endXYZ.y = value*Math.sin(endPhi);
                                                        chord.geometry.verticesNeedUpdate = true;
                                                        updateChordLength();
                                                    });
    endFolder.add(this, "endZ", -2.0, 2.0, 0.001).onChange(function(value) 
                                                     {
                                                         endXYZ.z = value;
                                                         chord.geometry.verticesNeedUpdate = true
                                                         updateChordLength();
                                                     });
    endFolder.add(this, "endPhi", 0, 2*Math.PI, 0.001).onChange(function(value) 
                                                          {
                                                              endXYZ.x = endR*Math.cos(value);
                                                              endXYZ.y = endR*Math.sin(value);
                                                              chord.geometry.verticesNeedUpdate = true;
                                                              updateChordLength();
                                                          });

    var chordFolder = gui.addFolder('Chord')
    chordFolder.add(this, "chordLength").listen();
    chordFolder.add(this, "recalculate")

    controlsFolder.open();
    startFolder.open();
    endFolder.open();
    chordFolder.open();
}

function updateChordLength()
{
    chordLength = Math.sqrt((endXYZ.x-startXYZ.x)**2+(endXYZ.y-startXYZ.y)**2+(endXYZ.z-startXYZ.z)**2)*1000;
}

function plotChord()
{
    var material = new THREE.LineBasicMaterial({
        color: 0xff0000,
        linewidth: 10 
    });

    var geometry = new THREE.Geometry();
    geometry.vertices.push(
        new THREE.Vector3( 6, -1.5, -0.5 ),
        new THREE.Vector3( 6, 1, 0 ),
    );

    chord = new THREE.Line( geometry, material );
    scene.add( chord );
}

function plotLCFS(input)
{
    var LCFS = new THREE.Object3D();
    // console.log(input.x)
    var mat = new THREE.LineBasicMaterial({ linewidth: 3, color: 0x000, transparent: true, opacity: 0.2 });
    for(i = 0; i < 126; i++) {
        var geom = new THREE.Geometry();
        for(j = 0; j < 80; j++) {
            geom.vertices.push(new THREE.Vector3(input.x[i*80+j], input.y[i*80+j], input.z[i*80+j]))
        }
        LCFS.add(new THREE.Line( geom, mat, THREE.LineSegments ));
    }
    scene.add(LCFS);
}

function getLookAtVector(controls)
{
    var phi = controls.getAzimuthalAngle();
    var theta = controls.getPolarAngle();
    return new THREE.Vector3(-Math.sin(theta)*Math.sin(phi), -Math.cos(theta), -Math.sin(theta)*Math.cos(phi));
}

function addSTL(filename)
{
    var loader = new THREE.STLLoader();
    loader.load( filename, function ( geometry ) {
        // Create ISS material, rotate, and position
        var STLMaterial = new THREE.MeshPhongMaterial( { color: 0x999999, specular: 0xfff, shininess: 50, side: THREE.DoubleSide } );
        var STL = new THREE.Mesh( geometry, STLMaterial );
        STL.scale.set( 0.001, 0.001, 0.001 );
        STL.castShadow = true;
        STL.receiveShadow = true;
        scene.add(STL);
    } );
}

function addLabel(text, x, y, z, color) 
{
    let sprite = new THREE.TextSprite({
        textSize: 0.3,
        texture: {
            text: text,
            fontFamily: 'Arial, Helvetica, sans-serif',
        },
        material: {color: color || 0x000},
    });
    sprite.position.setX(x).setY(y).setZ(z);
    scene.add(sprite);
}

function addAxes( length )
{
    var axes = new THREE.Object3D();
    axes.add( axis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( length, 0, 0 ), 0x000, false ) ); // +X
    axes.add( axis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0x000, true) ); // -X
    axes.add( axis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, length, 0 ), 0x000, false ) ); // +Y
    axes.add( axis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x000, true ) ); // -Y
    axes.add( axis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, length ), 0x000, false ) ); // +Z
    axes.add( axis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x000, true ) ); // -Z
    addLabel( 'x', 1.2*length, 0, 0 );
    addLabel( 'y', 0, 1.2*length, 0 );
    addLabel( 'z', 0, 0, 1.2*length );
    scene.add(axes);
}

function axis( src, dst, colorHex, dashed )
{
    var geom = new THREE.Geometry(),
        mat;
    if(dashed) {
        mat = new THREE.LineDashedMaterial({ linewidth: 3, color: colorHex, dashSize: 0.1, gapSize: 0.1, transparent: true, opacity: 0.4 });
    } else {
        mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex, transparent: true, opacity: 0.4 });
    }
    geom.vertices.push( src.clone() );
    geom.vertices.push( dst.clone() );
    geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines
    var axis = new THREE.Line( geom, mat, THREE.LineSegments );
    return axis;
}

function addLight( h, s, l, x, y, z )
{
    var light = new THREE.PointLight( 0xffffff, 1.5, 2000 );
    light.color.setHSL( h, s, l );
    light.position.set( x, y, z );
    scene.add( light );
}
</script>
</body>
</html>
